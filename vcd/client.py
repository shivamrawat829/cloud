import sys
import requests
from lxml import etree
from lxml import objectify
import json
from enum import Enum


class VmNicProperties(Enum):
    INDEX = 'index'
    CONNECTED = 'connected'
    PRIMARY = 'primary'
    NETWORK = 'network'
    IP_ADDRESS_MODE = 'ip_address_mode'
    IP_ADDRESS = 'ip_address'
    ADAPTER_TYPE = 'adapter_type'
    MAC_ADDRESS = 'mac_address'


class Client(object):
    _HEADER_ACCEPT_NAME = 'Accept'
    _HEADER_AUTHORIZATION_NAME = 'Authorization'
    _HEADER_CONNECTION_NAME = 'Connection'
    _HEADER_CONTENT_LENGTH_NAME = 'Content-Length'
    _HEADER_CONTENT_RANGE_NAME = 'Content-Range'
    _HEADER_CONTENT_TYPE_NAME = 'Content-Type'
    _HEADER_REQUEST_ID_NAME = 'X-VMWARE-VCLOUD-REQUEST-ID'
    _HEADER_X_VCLOUD_AUTH_NAME = 'x-vcloud-authorization'
    _HEADER_X_VMWARE_CLOUD_ACCESS_TOKEN_NAME = 'x-vmware-vcloud-access-token'

    _HEADER_CONNECTION_VALUE_CLOSE = 'close'

    _HEADERS_TO_REDACT = [
        _HEADER_AUTHORIZATION_NAME,
        _HEADER_X_VCLOUD_AUTH_NAME,
        _HEADER_X_VMWARE_CLOUD_ACCESS_TOKEN_NAME
    ]

    _UPLOAD_FRAGMENT_MAX_RETRIES = 5

    def __init__(self,
                 uri,
                 api_version=None,
                 verify_ssl_certs=True):
        self._logger = None

        self._verify_ssl_certs = verify_ssl_certs

        self.fsencoding = sys.getfilesystemencoding()

        self._api_base_uri = self._prep_base_uri(uri)
        self._cloudapi_base_uri = self._prep_base_uri(uri, True)
        self._api_version = api_version
        self._vcd_api_version = None
        if api_version:
            self._vcd_api_version = api_version

        self._session_endpoints = None
        self._session = None
        self._vcloud_session = None
        self._vcloud_auth_token = None
        self._vcloud_access_token = None
        self._query_list_map = None
        self._task_monitor = None

        self._is_sysadmin = False

    def is_admin(self, href):
        if '/api/admin/extension/' in href:
            return False
        elif '/api/admin/' in href:
            return True
        else:
            return False

    def get_admin_href(self, href):
        """Returns admin version of a given vCD url.

        This function is idempotent, which also means that if input href is already
        an admin href no further action would be taken.

        :param str href: the href whose admin version we need.

        :return: admin version of the href.

        :rtype: str
        """
        if '/api/admin/extension/' in href:
            return href.replace('/api/admin/extension', '/api/admin/')
        elif '/api/admin/' in href:
            return href
        else:
            return href.replace('/api/', '/api/admin/')

    def _prep_base_uri(self, uri, is_cloudapi=False):
        result = uri
        if len(result) > 0:
            if result[-1] != '/':
                result += '/'

            if is_cloudapi:
                result += 'cloudapi'
            else:
                result += 'api'

            if not result.startswith('https://') and not result.startswith('http://'):
                result = 'https://' + result
        return result

    def rehydrate_from_token(self, token, is_jwt_token=False):
        """Use authorization token to retrieve vCD session.

        This call will automatically negotiate the server API version if
        it was not set previously. The auto-negotiated API version cannot be a
        pre-release version. Note that the method may generate
        exceptions from the underlying socket connection, which we pass
        up unchanged to the client.

        :param str token: authorization token (either x-vcloud-authorization
            token or x-vmware-vcloud-access-token(JWT) generated by vCD).
        :param bool is_jwt_token:

        :raises: VcdException: if automatic API negotiation fails to arrive
            at a supported client version
        """
        # self._negotiate_api_version()

        new_session = requests.Session()
        try:
            if is_jwt_token:
                self._vcloud_access_token = token
                new_session.headers[self._HEADER_AUTHORIZATION_NAME] = \
                    'Bearer ' + self._vcloud_access_token
            else:
                new_session.headers[self._HEADER_X_VCLOUD_AUTH_NAME] = token

            self._session = new_session

        except Exception:
            new_session.close()
            raise

        # return self._vcloud_session

    def get_access_token(self):
        """Retrieve the access token.

        :return: the xvmware-vcloud-access token.

        :rtype: str
        """
        return self._vcloud_access_token

    def is_sysadmin(self):
        return self._is_sysadmin

    def get_org_list(self, params=None, objectify_results=True,
                     extra_headers=None):
        """Returns the list of organizations visible to the user.

        :return: a list of objects, where each object contains EntityType.ORG
            XML data which represents a single organization.

        :rtype: list
        """
        orgs = self._do_request(
            'GET', self._api_base_uri + '/org', objectify_results=objectify_results, params=params,
            extra_headers=extra_headers)

        result = []

        if hasattr(orgs, 'Org'):
            for org in orgs.Org:
                org_resource = self.get_resource(org.get('href'))
                result.append(org_resource)

        return result

    def get_org_by_name(self, org_name):
        orgs = self._do_request(
            'GET', self._api_base_uri + '/org', objectify_results=True, params=None,
            extra_headers=None)

        if hasattr(orgs, 'Org'):
            for org in orgs.Org:
                if org.get('name').lower() == org_name.lower():
                    return self.get_resource(org.get('href'))
        raise Exception('org \'%s\' not found' % org_name)

    def get_resource(self, uri, params=None, objectify_results=True,
                     extra_headers=None):
        """Gets the specified contents to the specified resource.

        This method does an HTTP GET.
        """
        return self._do_request(
            'GET', uri, objectify_results=objectify_results, params=params,
            extra_headers=extra_headers)

    def _do_request(self,
                        method,
                        uri,
                        contents=None,
                        media_type=None,
                        objectify_results=True,
                        params=None,
                        extra_headers=None):
            response = self._do_request_prim(
                method,
                uri,
                self._session,
                contents=contents,
                media_type=media_type,
                params=params,
                extra_headers=extra_headers)

            sc = response.status_code
            if sc in (requests.codes.ok,
                      requests.codes.created,
                      requests.codes.accepted,
                      requests.codes.no_content):
                return _objectify_response(response, objectify_results)

            self._response_code_to_exception(
                sc, self._get_response_request_id(response),
                _objectify_response(response, objectify_results))

    @staticmethod
    def _response_code_to_exception(sc, request_id, objectify_response):
        if sc == requests.codes.bad_request:
            raise 'Bad Request'

        if sc == requests.codes.unauthorized:
            raise 'Bad Request'

        if sc == requests.codes.forbidden:
            raise 'Bad Request'

        if sc == requests.codes.not_found:
            raise 'Bad Request'

        if sc == requests.codes.method_not_allowed:
            raise 'Bad Request'

        if sc == requests.codes.not_acceptable:
            raise 'Bad Request'

        if sc == requests.codes.request_timeout:
            raise 'Bad Request'

        if sc == requests.codes.conflict:
            raise 'Bad Request'

        if sc == requests.codes.unsupported_media_type:
            raise 'Bad Request'

        if sc == requests.codes.range_not_satisfiable:
            raise 'Bad Request'

        if sc == requests.codes.internal_server_error:
            raise 'Bad Request'

        raise 'Unknown'

    def _get_response_request_id(self, response):
        """Extract request id of a request to vCD from the response.

        :param requests.Response response: response from vCD.

        :return: the request id.

        :rtype: str
        """
        return response.headers.get('X-VMWARE-VCLOUD-REQUEST-ID')

    def _do_request_prim(self,
                         method,
                         uri,
                         session,
                         contents=None,
                         media_type=None,
                         accept_type=None,
                         auth=None,
                         params=None,
                         extra_headers=None):
        headers = extra_headers or {}
        if media_type is not None:
            headers[self._HEADER_CONTENT_TYPE_NAME] = media_type

        if not accept_type:
            accept_header = 'application/*+xml'
        else:
            accept_header = accept_type
        if self._api_version:
            accept_header += f";version={self._api_version}"
        headers[self._HEADER_ACCEPT_NAME] = accept_header

        if contents is None:
            data = None
        else:
            if isinstance(contents, dict):
                data = json.dumps(contents)
            else:
                data = etree.tostring(contents)

        response = session.request(
            method,
            uri,
            params=params,
            data=data,
            headers=headers,
            auth=auth,
            verify=self._verify_ssl_certs)

        return response


def _response_has_content(response):
    return response.content is not None and len(response.content) > 0


def _objectify_response(response, as_object=True):
    """Convert XML response content to an lxml object.

    :param str response: an XML response as a string.
    :param boolean as_object: If True convert to an
        lxml.objectify.ObjectifiedElement where XML properties look like
        python object attributes.

    :return: lxml.objectify.ObjectifiedElement or xml.etree.ElementTree object.

    :rtype: lxml.objectify.ObjectifiedElement
    """
    if _response_has_content(response):
        if as_object:
            return objectify.fromstring(response.content)
        else:
            return etree.fromstring(response.content)
    else:
        return None
